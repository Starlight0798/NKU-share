# Lab0.5

## 一.实验目的

实验0.5主要讲解最小可执行内核和启动流程。我们的内核主要在 Qemu 模拟器上运行，它可以模拟一台 64 位 RISC-V 计算机。为了让我们的内核能够正确对接到 Qemu 模拟器上，需要了解 Qemu 模拟器的启动流程，还需要一些程序内存布局和编译流程（特别是链接）相关知识。

## 二.实验过程

### 练习1:启动GDB验证启动流程

*为了熟悉使用qemu和gdb进行调试工作,使用gdb调试QEMU模拟的RISC-V计算机加电开始运行到执行应用程序的第一条指令（即跳转到0x80200000）这个阶段的执行过程，说明RISC-V硬件加电后的几条指令在哪里？完成了哪些功能？要求在报告中简要写出练习过程和回答。*

#### 第一阶段：复位

1.首先进入到riscv64-ucore-labcodes下的lab0中，同时打开两个shell后使用命令，结合gdb和qemu源码级调试ucore：

```bash
make debug
make gdb
```

![0.5-1](img/0.5-1.png)

在上图中可以看到RISC-V计算机加点开始启动**首先停在了`0x1000`处(即程序计数器PC首先被初始化为0x1000)**，这是**因为实际上RISC-V计算机上电时，第一件做的事其实是复位**。复位通常是指**将计算机系统的各个组件（包括处理器、内存、设备等）置于初始状态，并且会启动Bootloader。**而QEMU模拟的这款riscv处理器的**复位地址**是0x1000，而不是0x80000000。因此首先停在了这个位置上。

2.进入gdb中通过命令`x/10i $pc`查看0x1000处的10条汇编指令。

```bash
0x0000000000001000 in ?? ()
(gdb) x/10i $pc
=> 0x1000:	auipc	t0,0x0
   0x1004:	addi	a1,t0,32
   0x1008:	csrr	a0,mhartid
   0x100c:	ld	t0,24(t0)
   0x1010:	jr	t0
   0x1014:	unimp
   0x1016:	unimp
   0x1018:	unimp
   0x101a:	0x8000
   0x101c:	unimp
```

接下来对代码进行逐行的解析：

- `auipc t0, 0x0`: 将当前 PC 加上立即数（0），结果存入寄存器 t0。

- `addi a1, t0, 32`: 将寄存器 t0 的值加上立即数 32，结果存入寄存器 a1。

- `csrr a0, mhartid`: 读取 mhartid CSR（Machine Hart ID）的值到寄存器 a0。

- `ld t0, 24(t0)`: 从寄存器 t0 偏移 24 个字节处加载一个双字（64位）到寄存器 t0。

- `jr t0`: 跳转到寄存器 t0 指示的地址，**此时t0寄存器指示的地址就是0x80000000。**

- `unimp`: 未实现指令。

- `0x8000`: 直接的立即数。

**这些便是RISC-V硬件加电后的几条指令的一部分，由固化在 Qemu 内的一小段汇编程序负责，首先位于物理地址0x1000处。**用于在 RISC-V 架构中**进行程序控制和加载还有Bootloader的启动**，例如设置寄存器的值，跳转到指定地址，以及处理特殊情况。其中 `unimp` 表示未实现的指令。

接下来我们通过`si`命令逐行调试，最后通过`jr t0`跳转到物理地址 0x80000000 对应的指令处即启动Bootloader，并进入第二阶段。

#### 第二阶段：Bootloader即OpeSBI启动

进入到`0x80000000`后，以10条指令为代表简单分析这部分的指令和所完成的功能：

```bash
(gdb) si
0x0000000080000000 in ?? ()
(gdb) x/10i $pc
=> 0x80000000:	csrr	a6,mhartid
   0x80000004:	bgtz	a6,0x80000108
   0x80000008:	auipc	t0,0x0
   0x8000000c:	addi	t0,t0,1032
   0x80000010:	auipc	t1,0x0
   0x80000014:	addi	t1,t1,-16
   0x80000018:	sd	t1,0(t0)
   0x8000001c:	auipc	t0,0x0
   0x80000020:	addi	t0,t0,1020
   0x80000024:	ld	t0,0(t0)
```

接下来继续对这段代码进行逐行的解析：

1. `csrr a6, mhartid`: 从 `mhartid` CSR（Control and Status Register）中读取硬件线程 ID，并将结果存储在寄存器 a6 中。

2. `bgtz a6, 0x80000108`: 如果 a6 寄存器的值大于零，则跳转到地址 `0x80000108` 处执行，否则继续执行下一条指令。

3. `auipc t0, 0x0`: 将当前指令的地址的高 20 位加上一个偏移量（0x0），并将结果存储在 t0 寄存器中。

4. `addi t0, t0, 1032`: 将 t0 寄存器的值加上 1032，并将结果存储在 t0 寄存器中。

5. `auipc t1, 0x0`: 将当前指令的地址的高 20 位加上一个偏移量（0x0），并将结果存储在 t1 寄存器中。

6. `addi t1, t1, -16`: 将 t1 寄存器的值减去 16，并将结果存储在 t1 寄存器中。

7. `sd t1, 0(t0)`: 将 t1 寄存器的值存储到 t0 寄存器指定地址的内存位置。

8. `auipc t0, 0x0`: 将当前指令的地址的高 20 位加上一个偏移量（0x0），并将结果存储在 t0 寄存器中。

9. `addi t0, t0, 1020`: 将 t0 寄存器的值加上 1020，并将结果存储在 t0 寄存器中。

10. `ld t0, 0(t0)`: 将 t0 寄存器指定地址的内存内容加载到 t0 寄存器。

这些指令的含义与具体实现有关，特别是在特定的硬件和系统架构上即RISC-V架构上。**这些也是RISC-V硬件加电后的几条指令的一部分，由RISC-V架构中的Bootloader即OpenSBI获取计算机控制权后负责实现，位于物理地址0x80000000处。**这些指令包括**加载启动代码的地址、设置寄存器、获取处理器信息**等。在启动阶段，这些指令会被处理器执行，从而使处理器进入正确的状态以启动操作系统或其他应用程序。这是启动RISC-V处理器的非常重要的部分。

之后为了正确地和上一阶段的 OpenSBI 对接，我们需要保证内核的第一条指令位于物理地址 0x80200000 处，因为这里的代码是**地址相关的**，这个地址是由处理器，即Qemu指定的。为此，我们需要将内核镜像预先加载到 Qemu 物理内存以地址 0x80200000 开头的区域上。

#### 第三阶段：内核镜像启动

通过命令`break *0x80200000`在预先已经知道会被加载的内核镜像位置打上断点，并运行到对应位置。之后查看此处的10条指令。

```bash
(gdb) break *0x80200000
Breakpoint 1 at 0x80200000: file kern/init/entry.S, line 7.
(gdb) continue
Continuing.

Breakpoint 1, kern_entry () at kern/init/entry.S:7
7	    la sp, bootstacktop
(gdb) x/10i $pc
=> 0x80200000 <kern_entry>:		auipc	sp,0x3
   0x80200004 <kern_entry+4>:	mv	sp,sp
   0x80200008 <kern_entry+8>:	j	0x8020000c <kern_init>
   0x8020000c <kern_init>:		auipc	a0,0x3
   0x80200010 <kern_init+4>:	addi	a0,a0,-4
   0x80200014 <kern_init+8>:	auipc	a2,0x3
   0x80200018 <kern_init+12>:	addi	a2,a2,-12
   0x8020001c <kern_init+16>:	addi	sp,sp,-16
   0x8020001e <kern_init+18>:	li	a1,0
   0x80200020 <kern_init+20>:	sub	a2,a2,a0
```

同样对代码进行逐行解析：

1. `auipc sp, 0x3`: 将当前指令的地址的高 20 位加上一个偏移量（0x3），并将结果存储在栈指针寄存器 sp 中。

2. `mv sp, sp`: 将 sp 寄存器的值复制给 sp 寄存器，没有实质性的操作。

3. `j 0x8020000c`: 无条件跳转到地址 `0x8020000c` 处执行。

   以上三段代码等价于kern_entry中的：
	
	```assembly
	la sp, bootstacktop
	tail kern_init
	```
	
4. `auipc a0, 0x3`: 将当前指令的地址的高 20 位加上一个偏移量（0x3），并将结果存储在 a0 寄存器中。

5. `addi a0, a0, -4`: 将 a0 寄存器的值减去 4，并将结果存储在 a0 寄存器中。

6. `auipc a2, 0x3`: 将当前指令的地址的高 20 位加上一个偏移量（0x3），并将结果存储在 a2 寄存器中。

7. `addi a2, a2, -12`: 将 a2 寄存器的值减去 12，并将结果存储在 a2 寄存器中。

8. `addi sp, sp, -16`: 将 sp 寄存器的值减去 16，并将结果存储在 sp 寄存器中，通常用于为新的栈帧分配空间。

9. `li a1, 0`: 将立即数 0 加载到 a1 寄存器。

10. `sub a2, a2, a0`: 将 a2 寄存器的值减去 a0 寄存器的值，并将结果存储在 a2 寄存器中。

这段代码实际上是已经执行应用程序的第一条指令（即跳转到0x80200000即kern_entry）后的指令，**并不属于加电后的执行阶段了。主要用于内核的初始化等。但通常用于初始化寄存器、栈帧以及准备参数以调用其他函数。包括从kern_entry跳转到kern_init**。

### 总结

总的来说，在 Qemu 开始执行任何指令之前，**首先进行复位，然后两个文件将被加载到 Qemu 的物理内存中：**即作为 bootloader 的 OpenSBI.bin 被加载到物理内存以物理地址 0x80000000 开头的区域上，然后内核镜像 os.bin 被加载到以物理地址 0x80200000 开头的区域上。

## 三.实验中的知识点

**1.内核栈：**

​		**内核栈**是操作系统内核在运行过程中使用的一块内存区域，用于存储函数调用时的局部变量、函数参数和返回地址等信息。它是一个栈结构，遵循先进后出的原则。在引导过程中，bootloader是操作系统内核的启动程序，负责将操作系统加载到内存中并启动它。	  		bootloader在启动操作系统内核之前会初始化内核栈，并将控制权交给内核。内核栈在引导过程中的作用是提供一个存储空间，用于保存内核在运行过程中的临时数据。当操作系统内核被启动后，它会使用内核栈来执行各种操作，如处理中断、调度任务、处理系统调用等。因此，内核栈是操作系统内核的重要组成部分，它与bootloader的关系是bootloader负责初始化内核栈并启动内核，而内核则通过内核栈来执行各种操作。

**2.固件(firmware)**

​		**固件(firmware)**是一种特定的计算机软件，它为设备的特定硬件提供低级控制，也可以进一步加载其他软件。固件可以为设备更复杂的软件（如操作系统）提供标准化的操作环境。对于不太复杂的设备，固件可以直接充当设备的完整操作系统，执行所有控制、监视和数据操作功能。 在基于 x86 的计算机系统中, BIOS 或 UEFI 是固件；在基于 riscv 的计算机系统中，OpenSBI 是固件。OpenSBI运行在**M态（M-mode）**，因为固件需要直接访问硬件。

**3.地址相关代码与地址无关代码:**

地址无关代码（Position-Independent Code, PIC）和地址相关代码（Position-Dependent Code, PDC）是两种不同的代码类型，其主要区别在于代码中是否包含硬编码的内存地址。

**地址无关代码 (PIC)**:

- **含义**: 这种代码类型不依赖于固定的内存地址，可以在不同的内存位置加载和运行而不需要修改其本身代码。

- **特点**:
  - 使用相对寻址或寄存器间接寻址，避免了硬编码的内存地址。
  - 可以被加载到任意内存位置，而无需重定位（relocation）。
  - 通常用于共享库（shared libraries）或可执行文件，使得共享库可以在内存中的不同位置加载，同时可以减少不同程序的内存占用。

**地址相关代码 (PDC)**:

- **含义**: 这种代码类型包含了硬编码的内存地址，依赖于特定的内存布局。如果将其加载到不同的内存地址，可能会导致错误或崩溃。

- **特点**:
  - 包含直接使用内存地址的指令或数据。
  - 在加载到不同的内存位置时，可能需要对其进行重定位，修改内部的地址值。
  - 通常用于独立的可执行文件，对于每个程序，其被加载到内存的特定位置。

**区分总结**:

- **PIC**:
  - 不依赖于特定的内存地址。
  - 使用相对寻址或寄存器间接寻址。
  - 适用于共享库等场景。
  
- **PDC**:
  - 依赖于特定的内存地址。
  - 使用绝对寻址。
  - 适用于独立的可执行文件。
